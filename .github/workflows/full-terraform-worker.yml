on: 
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      destroy_after_deploy:
        required: true
        type: boolean
      destroy_only:
        required: true
        type: boolean
    outputs:
      vm_ip:
        description: "The public IP address of the deployed VM"
        value: ${{ jobs.terraform-deploy.outputs.vm_ip }}
      nsg_name:
        description: "The name of the Network Security Group"
        value: ${{ jobs.terraform-deploy.outputs.nsg_name }}
      rg_name:
        description: "The name of the Resource Group"
        value: ${{ jobs.terraform-deploy.outputs.rg_name }}

permissions:
  id-token: write
  contents: read

jobs:
  terraform-deploy:
    name: Deploy Terraform
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform/full
    env:
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    outputs:
      vm_ip: ${{ steps.terraform_outputs.outputs.VM_IP }}
      nsg_name: ${{ steps.terraform_outputs.outputs.NSG_NAME }}
      rg_name: ${{ steps.terraform_outputs.outputs.RG_NAME }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Azure login
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Install Terraform
      uses: hashicorp/setup-terraform@v2.0.3
      with:
        terraform_wrapper: false

    - name: Terraform Init
      run: |
        terraform init \
        -backend-config="resource_group_name=${{ secrets.BACKEND_RG_NAME }}" \
        -backend-config="storage_account_name=${{ secrets.BACKEND_STORAGE_NAME }}"

    - name: Select Terraform Workspace
      run: |
        terraform workspace select ${{ inputs.environment }} || terraform workspace new ${{ inputs.environment }}

    - name: Terraform Validate
      run: terraform validate
      
    - name: Terraform Plan
      if: inputs.destroy_only == false
      run: |
        terraform plan -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" -var="admin_username=${{ secrets.VM_ADMIN_USER }}" -var="env=${{ inputs.environment }}" \
        -var="cloudflare_zone=${{ secrets.CLOUDFLARE_ZONE_ID }}"  
    
    - name: Terraform Apply
      if: inputs.destroy_only == false
      run: |
        terraform apply -auto-approve -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" -var="admin_username=${{ secrets.VM_ADMIN_USER }}" -var="env=${{ inputs.environment }}" \
        -var="cloudflare_zone=${{ secrets.CLOUDFLARE_ZONE_ID }}"
      env: 
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_TOKEN }}

    - name: Output Terraform Outputs
      if: inputs.destroy_only == false
      id: terraform_outputs
      run: |
        VM_IP=$(terraform output -raw public_ip_address)
        echo "VM_IP=$VM_IP" >> $GITHUB_OUTPUT
        echo "The VM is accessible at IP: $VM_IP"

        NSG_NAME=$(terraform output -raw network_security_group_name)
        echo "NSG_NAME=$NSG_NAME" >> $GITHUB_OUTPUT
        echo "Network Security Group Name: $NSG_NAME"

        RG_NAME=$(terraform output -raw resource_group_name)
        echo "RG_NAME=$RG_NAME" >> $GITHUB_OUTPUT
        echo "Resource Group: $RG_NAME"

    - name: Terraform Destroy
      if: always() && (inputs.destroy_after_deploy == true || inputs.destroy_only == true)
      run: terraform destroy -auto-approve -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" -var="admin_username=${{ secrets.VM_ADMIN_USER }}" -var="env=${{ inputs.environment }}"
